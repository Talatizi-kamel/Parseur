3
1
0
2

 
c
e
D
6
1

 

 
 
]

M
D
.
s
c
[
 
 

1
v
5
4
3
4

.

2
1
3
1
:
v
i
X
r
a

An improved Branch-and-cut code for the maximum

balanced subgraph of a signed graph

Rosa Figueiredoa,∗, Yuri Frotab

aCIDMA, Department of Mathematics, University of Aveiro

3810-193 Aveiro, Portugal.

rosa.figueiredo@ua.pt

bDepartment of Computer Science, Fluminense Federal University

24210-240 Niter´oi-RJ, Brazil.

yuri@ic.uff.br

Abstract

The Maximum Balanced Subgraph Problem (MBSP) is the problem of ﬁnding a
subgraph of a signed graph that is balanced and maximizes the cardinality of its
vertex set. We are interested in the exact solution of the problem: an improved
version of a branch-and-cut algorithm is proposed. Extensive computational
experiments are carried out on a set of instances from three applications previ-
ously discussed in the literature as well as on a set of random instances.
Keywords: Balanced signed graph; Branch-and-cut; Portfolio analysis; Net-
work matrix; Community structure.

∗Corresponding author. Fax number: +351 234370066 Email: rosa.ﬁgueiredo@ua.pt

Rosa Figueiredo is supported by FEDER founds through COMPETE-Operational Programme
Factors of Competitiveness and by Portuguese founds through the CIDMA (University
of Aveiro) and FCT, within project PEst-C/MAT/UI4106/2011 with COMPETE number
FCOMP-01-0124-FEDER-022690.

Preprint submitted to Elsevier

December 17, 2013

1. Introduction

Let G = (V, E) be an undirected graph where V = {1, 2, . . . , n} is the set
of vertices and E is the set of edges connecting pairs of vertices. Consider a
function s : E → {+,−} that assigns a sign to each edge in E. An undirected
graph G together with a function s is called a signed graph. An edge e ∈ E is
called negative if s(e) = − and positive if s(e) = +.

In the last decades, signed graphs have shown to be a very attractive discrete
structure for social network researchers [1, 8, 9, 16, 21] and for researchers
in other scientiﬁc areas, including portfolio analysis in risk management [14,
15], biological systems [7, 15], eﬃcient document classiﬁcation [3], detection
of embedded matrix structures [12] and community structure [17, 20]. The
common element among all these applications is that all of them are deﬁned
in a collaborative vs. conﬂicting environment represented over a signed graph.
We refer the reader to [22] for a bibliography of signed graphs. Is this work we
consider the Maximum balanced subgraph problem (MBSP) deﬁned next.
Let G = (V, E, s) denote a signed graph and let E− and E+ denote, respec-
tively, the set of negative and positive edges in G. Also, for a vertex set S ⊆ V ,
let E[S] = {(i, j) ∈ E | i, j ∈ S} denote the subset of edges induced by S. A
signed graph G = (V, E, s) is balanced if its vertex set can be partitioned into
sets W (possibly empty) and V \ W in such a way that E[W ]∪ E[V \ W ] = E+.
Given a signed graph G = (V, E, s), the MBSP is the problem of ﬁnding a
subgraph H = (V (cid:48), E(cid:48), s) of G such that H is balanced and maximizes the
cardinality of V (cid:48).

The MBSP is known to be an NP-hard problem [6] although the problem
of detecting balance in signed graphs can be solved in polynomial time [13]. In
the literature, the MBSP has already been applied in the detection of embedded
matrix structures [10, 11, 12], in portfolio analysis in risk management [10] and
community structure [10].

The problem of detecting a maximum embedded reﬂected network (DMERN)
is reduced to the MBSP in [12]. Most of the existing solution approaches to the
MBSP were in fact proposed for the solution of the DMERN problem. The
literature proposes various heuristics for the solution of the DMERN problem
(for references see [12]). Lately, Figueiredo et al. [11] developed the ﬁrst ex-
act solution approach for the MBSP: a branch-and-cut algorithm based on the
signed graph reformulation from Gulpinar et al. [12] for the DMERN problem.
Computational experiments were carried out over a set of instances found in
the literature as a test set for the DMERN problem. Almost all these instances
were solved to optimality in a few seconds showing that they were not appropri-
ate for assessing the quality of a heuristic approach to the problem. Recently,
Figueiredo et al. [10] introduced applications of the MBSP in other two diﬀerent
research areas: portfolio analysis in risk management and community structure.
These authors also provided a new set of benchmark instances of the MBSP
(including a set of diﬃcult instances for the DMERN problem) and contributed
to the eﬃcient solution of the problem by developing a pre-processing routine,
an eﬃcient GRASP metaheuristic, and improved versions of a greedy heuristic

2

proposed in [12].

In this work we contribute to the eﬃcient solution of the MBSP by developing
an improved version of the branch-and-cut algorithm proposed by Figueiredo et
al. [11]. We introduce a new branching rule to the problem based on the odd
negative cycle inequalities. Moreover, we improve the cut generation component
of the branch-and-cut algorithm by implementing new separation routines and
by using a cut pool separation strategy.

The remainder of the paper is structured as follows. The integer program-
ming formulation and the branch-and-cut algorithm proposed in [11] to the
MBSP are outlined in Section 2. The improved version of the branch-and-cut
algorithm is described in Section 3.
In Section 4, computational results are
reported for random instances as well as for instances of the three applications
previously mentioned. In Section 5 we present concluding remarks.
We next give some notations and deﬁnitions to be used throughout the paper.
For an edge set B ⊆ E, let G[B] denote the subgraph of G induced by B. A
set K ⊆ V is called a clique if each pair of vertices in K is joined by an edge.
A set I ⊆ V is called a stable set if no pair of vertices in I is joined by an edge.
We represent a cycle by its vertex set C ⊆ V . In this text, a signed graph is
allowed to have parallel edges but no loops. Also, we assume that parallel edges
have always opposite signs.

2. Integer programming formulation and branch-and-cut

The integer programming formulation and the branch-and-cut algorithm in-

troduced in [11] are described next.

2.1. Integer programming formulation

It is well known that a signed graph is balanced if and only if it does not
contain a parallel edge or a cycle with an odd number of negative edges [5, 12,
22]. Let C o(E) be the set of all odd negative cycles in G, i.e., cycles with no
parallel edges and with an odd number of negative edges. Throughout this text,
a cycle C ∈ C o(E) is called an odd negative cycle. The formulation uses binary
decision variables y ∈ {0, 1}|V | deﬁned in the following way. For all i ∈ V , yi
is equal to 1 if vertex i ∈ V belongs to the balanced subgraph, and is equal
to 0 otherwise. We use the vector notation y = (yi), i ∈ V , and the notation

y(V (cid:48)) =(cid:80)

i∈V (cid:48) yi for V (cid:48) ⊆ V . The formulation follows.
Maximize y(V )
subject to yi + yj ≤ 1,

∀ (i, j) ∈ E− ∩ E+,
∀ C ∈ C o(E),
∀ i ∈ V.

(1)

(2)

(3)

(4)
Consider a parallel edge (i, j) ∈ E− ∩ E+. Constraints (2) ensure vertices i and
j cannot belong together to the balanced subgraph. Constraints (3), called odd
negative cycle inequalities, forbid cycles with an odd number of negative edges

y(C) ≤ |C| − 1,
yi ∈ {0, 1},

3

in the subgraph described by variables y. These constraints force variables y
to deﬁne a balanced subgraph. Finally, the objective function (1) looks for a
maximum balanced subgraph. The formulation has n variables and, due to
constraints (3), might have an exponential number of constraints. Let us refer
to this formulation as Y (G, s). By changing the integrality constraints (4) in
formulation Y (G, s) by the set of trivial inequalities 0 ≤ yi ≤ 1, i ∈ V , we
obtain a linear relaxation to the MBSP.

2.2. A branch-and-cut algorithm

The branch-and-cut algorithm developed in [11] is based on formulation
Y (G, s), uses a standard 0–1 branching rule and has three basic components:
the initial formulation, the cut generation and the primal heuristic.

Initial formulation. The initial formulation is deﬁned as

maximize y(V )
subject to y(K) ≤ 1,

y(C) ≤ |C| − 1,
y(K) ≤ 2,
0 ≤ yi ≤ 1,

∀ K ∈ L,
∀ C ∈ M ⊆ C o(E),
∀ K ∈ N,
∀ i ∈ V,

(5)

(6)

(7)

(8)

where (5) are clique inequalities from the stable set problem [19] deﬁned over a
set of cliques L in G[E+ ∩ E−]; (6) is a subset of inequalities (3) deﬁned over
a set of odd negative cycles M ; (7) is a subset of inequalities from a family of
negative clique inequalities introduced in [11] for the MBSP and deﬁned over a
set of cliques N in G[E−]; (8) is the set of trivial inequalities. Greedy procedures
described in [11] are used to generate sets L, M and N .

Cut generation. After an LP has been solved in the branch-and-cut tree, the
algorithm check if the solution is integer feasible. If this is not the case, the cut
generation procedure is called and a set of separation routines is executed (a
limit of 100 cuts per iteration is set). If no violated inequality is found or if a limit
of 10 cut generations rounds is reached, the algorithm enter in the branching
phase. The cut generation component described in [11] has two separation
procedures. An exact separation procedure is used to generate violated odd
negative cycle inequalities (3). This separation routine is based on a polynomial
algorithm described in [4] to solve the separation problem for cut inequalities. A
heuristic separation procedure deﬁned in [11] is used to generate violated clique
inequalities also introduced in [11].

Primal heuristic and branching rule. A rounding primal heuristic is exe-
cuted in [11] every time a fractional solution is found. Moreover, a standard 0–1
branching rule is used with the same branching priority assigned to each variable
and the branch-and-cut tree is investigated with the best-bound-ﬁrst strategy.
The authors reported they have also implemented a version of the branching

4

rule proposed in [2]. Although this branching rule has been successfully applied
to solve the stable set problem, they obtained better results with the standard
0–1 branching rule.

3. An improved branch-and-cut code

In this work, the following new routines were added to the branch-and-cut

algorithm described in Section 2.

Branching on the odd negative cycle inequalities. Our branching rule
is based on the odd negative cycle inequalities (3). The intuition behind this
cycle based branching is the attempt to generate more balanced enumerative
trees. The standard 0–1 branching rule can be very asymmetrical producing
unbalanced enumerative trees.
Let ¯y ∈ R be the optimal fractional solution of a node in the search tree. Let
C(cid:48) ⊆ C o(E) be the subset of odd negative cycles such that each cycle C ∈ C(cid:48)
satisfy the following conditions:

• constraint (3) deﬁned by C(cid:48) is a binding one in the current formulation,
• there exists a vertex i ∈ C(cid:48) such that ¯yi is fractional.
The standard 0–1 branching rule is used whenever C(cid:48) is an empty set. If it
is not the case, let ¯C be the smallest cycle in C(cid:48). Split ¯C into the sets ¯C 1 and
¯C 2 such that ¯C = ¯C 1 ∪ ¯C 2, ¯C 1 ∩ ¯C 2 = ∅ and y( ¯C 1) is fractional. We create
three branches in the search tree:

(i) y( ¯C 1) ≤ | ¯C 1| − 1 and y( ¯C 2) = | ¯C 2|;
(ii) y( ¯C 1) = | ¯C 1| and y( ¯C 2) ≤ | ¯C 2| − 1;
(iii) y( ¯C 1) ≤ | ¯C 1| − 1 and y( ¯C 2) ≤ | ¯C 2| − 1.

Separation routines. In this work, we introduce two new separation pro-
cedures to the cut generation component of the branch-and-cut algorithm de-
scribed in Section 2.
The authors in [11] proved that lifted odd hole inequalities (from the stable
set problem) deﬁned over the set of parallel edges E+ ∩ E− are valid inequal-
ities for the MBSP. They have also proved that, if the support graph of these
inequalities satisfy certain conditions they are facet deﬁning inequalities to the
problem. We implemented a separation procedure described in [18] to the lifted
odd hole inequalities. Also, the authors indicated in [11] that a very similar lift-
ing procedure could be applied to strengthen constraints (3). We implemented
this lifting procedure to the odd negative cycle inequalities satisfying |C| ≤ 20.
In both cases, a very small instance of the MBSP must be solved at each it-
eration of the lifting procedures. In our implementation, these small problems
were solved by simple enumerative algorithms.

5

Moreover, we added a cut pool to the branch-and-cut code: any violated
inequality included to the active formulation of a node in the branch-and-cut
tree is also included to the cut pool. As we have mentioned in Section 2, after an
LP has been solved in the branch-and-cut tree, we check if the solution is integer
feasible.
If this is not the case, the cut generation procedure is then called.
Before running any separation routine from our cut generation procedure, we
check if there are violated cuts in the cut pool. In positive case, no separation
routine is called and the violated cuts (limited to 100 cuts) are immediately
added to the active formulation.

4. Computational experiments

We implemented the improved branch-and-cut algorithm described in Sec-
tion 3 using the formulation deﬁned by (5)-(8). Both branch-and-cuts (BC), the
previous one and the improved version, were implemented in C++ running on
a Intel(R) Pentium(R) 4 CPU 3.06 GHz, equipped with 3 GB of RAM. We use
Xpress-Optimizer 20.00.21 to implement the components of these enumerative
algorithms. The maximum running time per instance was set at 3600 seconds.
The same instance classes reported in [10] were tested here to allow for a better
comparison of the performances of the improved BC and the BC algorithm pro-
posed earlier. The class Random consists of 216 randomized instances divided
into two groups: Group 1 without parallel edges and Group 2 with parallel
edges. The class UNGA is composed of 63 instances derived from the com-
munity structure of networks representing voting on resolutions in the United
Nations General Assembly. The class new DMERN consists of 316 signed graphs
coming from a set of general mixed integer programs. Finally, the class Porti-
folio is composed by 850 instances generated from market graphs. The entire
benchmark is available for download in www.ic.uff.br/∼yuri/mbsp.html.

We ﬁrst investigate the behavior of the Random instances, the results ob-
tained by the two methods are summarized in Table 1. This table exhibits, for
both groups, average times per | V |, and percentage gaps per | V |, d (density
of the graph) and the rates | E− | / | E+ | and | E+ ∩ E− |. Multicolumn
Time, gives us average times (in seconds) spent to solve instances to optimal-
ity; the values in brackets show the number of instances solved to optimality
(“-” means no instance was solved within the time limit). Multicolumn %Gap
presents the average of percentage gaps calculated over the set of unsolved in-
stances. The percentage gap of each instance is calculated between the best
integer solution found and the ﬁnal upper bound. For each group of instances,
the ﬁrst and the second lines present, respectively, the results obtained with the
original and the improved code of the branch-and-cut algorithm. The results
obtained with the improved version are slightly better: six more instances were
solved to optimality and all the average gaps were reduced.

In the second experiment, we analyze the performance of the Portifolio in-
stances. Table 2 reports the obtained results. The ﬁrst two columns give the
number of vertices and a threshold value t used to generate the instances [10].
The next three columns give the average time, the average of percentage gaps

6

(as deﬁned in Table 1) and the number of evaluated nodes in the original BC
tree, respectively. The last three columns give the same data for the improved
BC. Algorithm improved BC solved 227 out of 850 instances within 1 hour of
processing time, while the original BC managed to solve only 217 instances. The
average gap for the original BC over the set of unsolved instances is 17.91%,
while the same value for the improved version is 9.41%. Furthermore, Figure 1
shows that the improved BC presents tighter gaps for almost the entire set of
Portifolio instances than the original one.

In the third experiment, we investigate the behavior of the UNGA instances.
We notice that these instances are extremely easy to solve. No matter the
number of vertices or the parameters used to compose the instance, both BC
codes were always able to solve all of them in a few seconds and in the root
of the branch-and-bound tree. So, we could not draw any conclusion from this
class of instance.

In our last experiment, both methods were applied to each one of the 316 new
DMERN instances [10]. Table 3 shows the results for the instances remaining
unsolved and the instances solved to optimality in more than one minute. The
ﬁrst three columns in this table give us information about the instances: the
Netlib instance name, the number of vertices and the number of edges. The
next three columns give the number of negative, positive and parallel edges,
respectively. Similarly to the previous table, the next set of three columns gives
us information about the solution obtained with the original BC code: the time,
the percentage gap, and the total number of nodes in the branch-and-bound tree.
The last three columns give the same data for the improved BC. From this set
of instances, we can extract 25 instances not solved to optimality by the original
BC code with average gap of 11.42% of unsolved instances, while the improved
BC could not solve 21 instances but with a much tighter average gap of 4.85%.
One can notice that the implementation of new separation routines and a new
branching rule used in the improved BC led to a better performance and a high
number of evaluated nodes within the time limit.

5. Final remarks

In this work, we proposed an improved branch-and-cut algorithm based on
the integer programming formulation and the BC algorithm proposed in [11],
together with a new branching rule based on the odd negative cycle inequalities
and improved cutting plane routines and strategies. The instance classes re-
ported in [10] were used to compare the performances of the improved BC and
the original BC algorithm proposed in [11]. The results obtained by the new ap-
proach were superior to those given by the previously existing branch-and-cut.
The new method solved 431 out of 1445 instances within 1 hour of processing
time, while the original algorithm managed to solve only 410 instances. More-
over, as we saw in Section 4, considering only the set of unsolved instances, the
average gap obtained with the improved BC was smaller than the average gap
obtained with the original BC from [11].

7

|

E
|
/
)
|

+
E
∩
−

E
|
(

|

+
E
|
/
|

−

E

|

−

−

5
7
.

−

−

0
5
.

−

−

5
2
.

5
3
.
1
2

4
7
.
8
1

2
2
.
2
4

1
7
.
8
3

9
6
.
8
6

4
8
.
3
6

2

1

0
5
.

1
3
.
0
8

1
0
.
6
8

4
8
.
5
7

−

−

7
2
.
4
7

−

−

8
4
.
6
7

−

−

6
1
.
7
6

p
a
G
%

5
7
.

3
8
.
2
8

6
3
.
6
7

8
7
.
5
6

7
9
.
1
6

d

0
5
.

3
0
.
8
8

7
2
.
1
8

8
2
.
6
5

2
9
.
0
5

5
2
.

8
4
.
5
7

6
2
.
5
6

8
4
.
3
3

4
7
.
0
3

0
0
2

2
4
.
3
5
1

4
3
.
4
4
1

3
8
.
1
1
1

6
3
.
4
0
1

9
0
.
2
9

8
0
.
9
4

7
0
.
4
4

5
5
.
4
0
1

5
0
.
7
3

2
6
.
6
2

7
1
.
6

4
8
.
4

0

0

0

0

0
5
1

0
0
1

0
5

|

V

|

−

−

−

−

0
0
2

e
m
T

i

|

V

|

0
5
1

0
0
1

0
5

−

−

)
9
(
8
7
.
0
1
9

)
9
(
7
6
.
7
7
2
1

)
3
(
0
0
.
8
7
5
2

)
9
(
3
3
.
8
2
7
1

)
1
2
(
0
9
.
3
7
4

)
1
2
(
3
3
.
3
2
3

)
7
2
(
2
2
.
4
2

)
7
2
(
3
6
.
0
1

)
7
2
(
1
4
.
2

)
7
2
(
7
3
.
2

s
e
c
n
a
t
s
n
I

1

p
u
o
r
G

2

p
u
o
r
G

8

.
)
∅
=
+
E
∩
−

E
(

2

p
u
o
r
G
n

i

d
n
a

)
∅
=
+
E
∩
−

E
(

1

p
u
o
r
G
n

i

s
e
c
n
a
t
s
n

i

m
o
d
n
a
r

n
o

d
e
n
i
a
t
b
o

s
t
l
u
s
e
R

:
1

e
l
b
a
T

(cid:54)
Instance
|V |
330

360

390

420

450

480

510

t
0.300
0.325
0.350
0.375
0.400
0.300
0.325
0.350
0.375
0.400
0.300
0.325
0.350
0.375
0.400
0.300
0.325
0.350
0.375
0.400
0.300
0.325
0.350
0.375
0.400
0.300
0.325
0.350
0.375
0.400
0.300
0.325
0.350
0.375
0.400

Figure 1: Results obtained on portfolio instances.

Original BC

Improved BC

Time %Gap
10.66
4.61
-
-
-
19.24
4.05
-
-
-
29.52
17.15
2.40
-
-
30.56
13.63
12.04
-
-
35.86
14.75
2.40
-
-
42.69
27.53
10.33
1.20
-
49.59
34.39
12.36
1.05
-
17.91

25.00(2)
295.25(8)
13.00(10)
1.50(10)
1.00(10)
1145.67(3)
170.75(4)
161.10(10)
3.10(10)
1.10(10)
141.00(1)
255.50(4)
81.71(7)
4.30(10)
1.30(10)
-
1062.50(2)
176.14(7)
192.10(10)
7.40(10)
-
342.00(1)
444.00(8)
18.10(10)
2.40(10)
2065.00(1)
1746.33(2)
385.20(5)
43.22(9)
23.90(10)
2809.00(1)
392.00(2)
47.00(3)
101.29(7)
6.60(10)
(217)

Nodes
890.70
467.40
13.60
1.80
1.00
561.90
611.90
100.90
2.20
1.40
498.80
461.80
372.80
2.40
1.10
401.70
432.30
285.90
131.70
15.60
313.70
360.40
241.70
8.40
1.30
243.60
321.40
288.70
105.30
25.90
199.50
217.40
242.30
299.70
4.00

Time %Gap
4.56
2.82
-
-
-
6.48
2.39
-
-
-
10.74
4.41
1.84
-
-
15.86
8.24
3.98
-
-
14.45
5.24
2.56
-
-
30.20
13.66
3.43
-
-
33.17
19.92
3.70
0.53
-
9.41

183.33(3)
83.13(8)
21.30(10)
1.80(10)
1.00(10)
195.67(3)
331.00(5)
129.90(10)
3.90(10)
1.20(10)
650.50(2)
101.25(4)
29.14(7)
5.20(10)
1.40(10)
-
1442.33(3)
116.29(7)
155.20(10)
4.40(10)
-
124.00(1)
390.89(9)
24.00(10)
2.70(10)
740.00(1)
546.33(3)
218.80(5)
170.90(10)
7.30(10)
943.50(2)
459.00(2)
59.67(3)
670.89(9)
7.60(10)
(227)

Nodes
933.50
431.60
34.80
2.70
1.00
581.20
914.20
135.50
4.40
1.50
472.30
511.40
551.30
4.40
1.70
395.70
548.30
322.60
201.10
11.50
330.40
375.80
248.20
17.20
1.00
261.10
298.10
318.80
83.40
7.00
182.60
244.70
315.70
563.90
4.40

Table 2: Results obtained on portfolio instances.

9

1
5
9
3

0
1
7
9
3

-

-

)
1
(
4
6
1

)
1
(
5
5
7
2

6
1

8
0
5

9
9
3

1

5
9

1
7

7
2

1

3
5

3
2
2

1

1

3

2

1

1

2

3
4

0
1

9
8
4

9
1
5

1

1

1

1

3

3
4
.
0
4

-

8
9
.
0
3

-

3
0
.
4

-

-

-

)
1
(
2
4
6

)
1
(
2
7
1

-

-

)
1
(
0
6

)
1
(
2
6

-

-

-

-

-

-

-

-

)
1
(
9
9
6

)
1
(
9
2

)
1
(
3
1
1

)
1
(
6
5

)
1
(
3
8

)
1
(
3
8
7

)
1
(
9
2

)
1
(
7
6
1

3
4
.
5
8

-

-

-

-

9
5
.
0

3
6
.
0

-

-

-

-

-

)
1
(
9
1
1

)
1
(
9
6
1

)
1
(
6
0
1

-

-

)
1
(
3
1
2

)
1
(
6
2
1

)
1
(
5
1
2

)
1
(
9
5
2

)
1
(
4
2
4

9
4
3
4

3
2
5
2

1
5
6

8
6

9
9
3

1

4
9

1
7

1
2

3
2
2

1

3
5

1

1

8

3

4
2

1

6
3

3
1

5
7

1

1

1

1

1

9
7
4

4
9
4

-

-

-

)
1
(
9
8
2

)
1
(
0
6
3

)
1
(
3
6
2
2

0
0
.
4
6
1

-

5
0
.
4
1

-

3
7
.
3
3

-

-

)
1
(
1
8
1

-

-

)
1
(
8
3

)
1
(
4
6

-

-

-

-

-

)
1
(
7
2
7

)
1
(
5
7

)
1
(
6
1
1

)
1
(
0
7

)
1
(
6
6

7
6
.
4
7
2

-

5
6
.
8
7

-

-

-

)
1
(
9
0
1

)
1
(
9
3
1

-

-

-

9
5
.
0

3
6
.
0

-

-

-

-

-

-

-

)
1
(
3
9

)
1
(
3
9
6

)
1
(
4
2
5

)
1
(
3
3
2

)
1
(
1
0
1

)
1
(
1
0
2

)
1
(
4
3
2

)
1
(
8
2
2

0

0

0

0

0

6
5

5
8
4

0

0

0

0

0

0

0

0

0

6
8

0

5
5
5

4
5
0
4

0

0

0

0

0

0

0

0

s
e
d
o
N

p
a
G
%

e
m
T

i

s
e
d
o
N

p
a
G
%

e
m
T

i

C
B
d
e
v
o
r
p
m

I

C
B

l
a
n
i
g
i
r
O

+
−
m

+
m

3
0
9

7
6
5

0

0

0
3
5

0

0

5
4
8

0

4
7
9

0

0

7
7
9

3
8
3
1

8
7
2
5

2
9
0
1

1
7
6
7

3
0
0
1
3

8
9
3
5

0
3
6
1
3

1
5
8
3

2
4
7
1

4
1
7
1

0
6
1
6

6
6
4
4

6
4
1
7

1
2
9
6

0

9
2
1

9
4
.
0
2

-

8
3
1

9
2
.
8
1

-

2
2
6
1

5
9
1
0
1

7

7

7

7

7

7

7

1

4

1

3

3

0
2

5

1

1

1

7
1

3
2

1

3

7
1

7

1

0
1

1
1

1

1

1

1

9

0
7

2
6

2

2

0

0

1

1

0

6
2
.
5
7
6

-

-

-

-

-

-

-

-

)
1
(
1
1

)
1
(
0
1

)
1
(
1
1

)
1
(
0
1

)
1
(
1
1

)
1
(
0
1

)
1
(
1
1

)
1
(
9
8

0
4
.
3
5

-

6
8
.
2

-

-

-

-

)
1
(
0
1
1

)
1
(
4
8
1
1

)
1
(
1
2
3
1

-

-

-

-

-

)
1
(
1
1
2

)
1
(
1
2
8
2

)
1
(
9
4
0
1

)
1
(
3
0
8

)
1
(
0
6
2

6
7
.
8

-

-

-

-

4
9
.
0

4
8
.
5

9
0
.
1
1

4
8
.
3
1

-

-

-

-

-

5
8
.
0

2
5
.
4

9
1
.
1

2
9
.
7

5
2
.
5
1

5
2
.
5
1

-

-

5
8
.
4

8
3
.
0
1

)
1
(
3
7
1

)
1
(
3
5
7
2

-

-

)
1
(
4
6
4

-

-

)
1
(
8
3
3

)
1
(
1
3
4

)
1
(
5
2
2

)
1
(
1
4
2

-

-

-

)
1
(
0
8
3
2

-

-

-

-

)
1
(
2
2
3
1

)
1
(
3
7
1
1

1
9

1
9

1
9

1
9

1
9

1
9

1
9

1

3

1

3

4

8

1

1

1
1

7
1

1

9
2

1

1

6
1

9
1

1

4
1

1
1

1

1

1

1

9

8
6

9
5

3

3

0

0

1

1

0

)
8
4
(
6
0
.
8
1
5

9
4
.
4
5
1

-

-

-

-

-

-

-

-

)
1
(
2
1
1

)
1
(
1
1
1

)
1
(
1
1
1

)
1
(
0
1
1

)
1
(
0
1
1

)
1
(
0
1
1

)
1
(
0
1
1

)
1
(
3
1

7
0
.
3
5

-

-

-

9
0
.
0

7
7
.
2
5

5
4
.
4

-

-

-

-

-

-

2
1
.
6

-

4
9
.
0

2
7
.
5

9
0
.
1
1

0
3
.
4
1

-

-

-

-

-

5
8
.
0

9
5
.
4

2
2
.
1

1
8
.
8

2
4
.
4
1

2
4
.
4
1

-

-

8
3
.
0
1

2
4
.
1
1

)
1
(
1
1
1

)
1
(
1
3
4
1

-

-

-

)
1
(
6
3
2

)
1
(
1
4
3
1

)
1
(
9
1
8

)
1
(
8
7
2

-

)
1
(
1
2

-

-

-

-

-

-

)
1
(
0
8
3

-

-

)
1
(
9
2
3

)
1
(
1
0
4

)
1
(
3
2
2

)
1
(
2
4
2

)
1
(
3
4
0
3

-

-

-

-

)
1
(
9
3
4

)
1
(
0
2
3
1

)
3
4
(
5
7
.
3
1
4

0

0

0

0

0

0

0

0

0

0

0

0

0

6
2
7
6

3
6
0
1

0
7
8

0

0

0
5
4

6
9
8
7

0

0

0

0
6

6
4

6
4

3

0

1
8

1
8

0

0

0

0

0

0

0

7
3

0
4
6
2

0
4
9
2

0
4
9
2

0
4
9
2

0
4
9
2

0
4
9
2

0
4
9
2

0
4
9
2

1
9
6
2

0

5
9
3
8
5

6
5
2
2
1

0
0
9
6
1

3
8
6
3
1

5
5
2
0
2

4
3
0
3

0
4
5
3
1

5
9
1
3

7
0
9
5

4
3
8
1

7
2
8
6
1

4
6
5
6
1

7
2
9
3

0
4
4
3
1

7
6
3
4

1
7
5
8
1

7
9
6
9
1

3
9
7
2

0

9
7
1
2
2

4
0
8
2
2

2
0
9
4

0
2
8
3

6
0
4
4

6
1
7
8

0
8
3
6
3

0

0

0

0

0
1
2

9
4
5
7
1

−
m

7
9
4

1
8
9
1

1
2
5

1
0
7
0
1

0
0
0
0
3

7
5
2
0
3

0
7
3
7
1
1

5
2
6

6
2
0
1

2
9
5
5
5

2
5
9
3
1

5
9
8

4
6
2
2

2
7
4
5

3
7
3
7
3

5
9
2
2
2

0
7
6
7

8
4
9
4
1

8
5
2
6

2
2
0
5
2

8
8
7
0
1

8
2
2
1

6
5
2
1

1
9
4
5

7
7
7
5

9
7
5
7

5
3
9
7

0
0
2
5
3

3
8
9
4
2

3
9
3
1

3
9
3
1

3
9
3
1

3
9
3
1

3
9
3
1

3
9
3
1

3
9
3
1

3
4
1
1

9
1
2
0
3

7
9
2
0
1

0
2
2
2
1

0
8
2
6
1

2
1
9
0
3

2
0
6
8
1

1
9
9
6

6
5
9
2
1

5
8
4
6

5
2
3
6

2
8
5
2

2
4
8
3
4

4
6
6
4
1

3
0
7
2

5
8
6
3
3

0
9
0
9

7
6
5
5
5

9
6
5
4
5

3
0
5
3

6
8
1
8

2
1
8
9
4

1
0
3
2
5

3
6
3
3

0
5
6
3

4
6
0
3

6
1
9
7

0
5
8
1
4

7
0
0
4
0
6

7
0
0
4
0
6

0
0
0
5
1

0
0
9
2
7

7
6
9
2
0
3

m

6
5
4
1

8
4
5
2

1
0
7
0
1

0
0
0
0
3

1
5
0
1

7
5
2
0
3

5
5
8
7
1
1

0
7
4
1

2
9
5
5
5

0
0
0
2

2
5
9
3
1

2
7
8
1

3
3
7
3

0
5
7
0
1

3
7
3
7
3

7
8
3
3
2

1
4
3
5
1

6
0
5
6
4

6
5
6
1
1

6
0
7
0
6

9
3
6
4
1

0
7
9
2

0
7
9
2

1
5
6
1
1

3
4
2
0
1

5
2
7
4
1

6
5
8
4
1

0
0
2
5
3

0
0
8
6
3

3
3
3
4

3
3
3
4

3
3
3
4

3
3
3
4

3
3
3
4

3
3
3
4

3
3
3
4

0
6
5
0
1

7
7
6
9
8

7
6
1
1
1

6
7
4
4
2

0
8
1
3
3

5
9
5
4
4

7
5
8
8
3

5
2
0
0
1

6
9
4
6
2

0
3
1
0
1

2
3
2
2
1

9
6
6
0
6

2
1
3
2
1

8
2
2
1
3

0
3
6
6

5
8
1
7
4

7
5
4
3
1

4
8
1
4
7

2
1
3
4
7

9
9
2
6

6
8
1
8

2
7
0
2
7

6
8
1
5
7

5
6
2
8

0
7
4
7

0
7
4
7

9
6
6
6
1

0
7
8
0
8

7
0
0
4
0
6

7
0
0
4
0
6

0
0
0
5
1

0
0
9
2
7

6
2
7
0
2
3

n

4
4
1

4
8
1

1
3
3

9
9
3

4
1
4

6
2
4

6
8
4

8
8
6

3
2
8

0
8
8

2
1
9

4
1
9

3
0
0
1

2
1
0
1

5
8
0
1

0
2
1
1

8
7
1
1

7
2
2
1

0
0
3
1

0
0
3
1

0
2
3
1

8
8
3
1

8
8
3
1

3
4
6
1

9
4
6
1

1
6
6
1

2
5
7
1

0
2
8
1

6
6
8
1

8
7
8
1

8
7
8
1

8
7
8
1

8
7
8
1

8
7
8
1

8
7
8
1

8
7
8
1

8
8
0
2

2
1
1
2

4
7
1
2

8
7
2
2

0
8
2
2

6
8
2
2

3
0
3
2

7
4
3
2

8
5
3
2

0
0
4
2

8
3
4
2

0
2
5
2

8
7
5
2

6
8
6
2

4
0
7
2

6
0
7
2

7
3
8
2

7
4
0
3

2
5
0
3

7
2
1
3

0
4
2
3

9
4
2
3

5
8
2
3

4
6
3
3

8
8
4
3

8
8
4
3

4
9
2
4

2
3
7
4

4
9
7
4

4
9
7
4

0
5
1
5

0
8
4
6

7
1
3
8

e
c
n
a
t
s
n
I

-

-

-

-

-

-

N
N
A
C
N
M
D
D
–
a
c
-
s
u
-
s
o
n
a
j

-

t
n
i
o
n
a
d

1
t
s
n
e
i
b

5
4
n
i
e
t
s

m
o
t
c
s
i
d

e
m
a
N

1
.
0
2
.
0
6
.
c
f

8
8
5
x
0
0
1
p

7
1
s
o
e
n

5
0
r
i
a

0
0
8
x
0
8
r

8
0
g
u
n

4
6
8
x
0
5
p

p
i
m
b
s
d

4
0
r
i
a

1
2
s
o
e
n

3
2
s
o
e
n

3
-
5
n

3
-
4
n

p
i
m
3
o
n
a
d

0
0
0
3
l
l
o
r

0
2
s
o
e
n

3
-
8
n

c
8
8
1
1
x
0
0
2
p

8
8
1
1
x
0
0
2
p

-

-

-

-

-

N
N
A
C
N
M
B
D
–
0
4
o
r
o
i
p

-

-

7
4
3
8
8
6
1
s
n

3
r
p
-
5
2
s
n

3
r
p
-
0
6
s
n

3
r
p
-
4
s
n

3
r
p
-
0
2
1
u
n

3
r
p
-
5
2
u
n

3
r
p
-
4
u
n

3
r
p
-
0
6
u
n

3
-
3
1
n

3
-
2
n

0
1
p
a
q

-

-

-

-

-

-

N
N
A
C
N
M
U
U
–
0
5
y
n
a
m
r
e
g

-

-

-

-

-

N
N
A
C
N
-
E
-
B
D
–
4
5
b
i
z

-

8
1
9
8
1
8
s
o
e
n

3
-
2
1
n

d
l
o
f
t
o
r
p

0
0
0
6
p
a
c

3
-
7
n

3
-
9
n

1
-
c
c
a

3
-
3
n

10

-

-

-

-

-

-

N
N
A
C
N
M
B
D
–
0
5
y
n
a
m
r
e
g

-

2
-
c
c
a

-

-

-

-

N
N
A
C
N
M
U
U
–
2
a
t

-

-

-

1
1
s
o
e
n

n
i
l
r
e
b

3
-
6
n

-

-

-

-

N
N
A
C
N
M
B
D
–
2
a
t

-

-

-

1
1
0
d
o
m

3
-
c
c
a

4
-
c
c
a

l
i
s
a
r
b

6
-
c
c
a

5
-
c
c
a

c
k
m

c
8
8
9
2
x
0
0
5
p

8
8
9
2
x
0
0
5
p

r
a
c
a
t
n
e
r

1
s
o
e
n

1
r
u
o
m
y
e
s

r
u
o
m
y
e
s

1
8
a
n
n
a
m

2
1
s
o
e
n

a
0
7
3
n

.
s
e
c
n
a
t
s
n

i

N
R
E
M
D
w
e
n

e
h
t

n
o

d
e
n
i
a
t
b
o

s
t
l
u
s
e
R

:
3

e
l
b
a
T

References

[1] P. Abell and M. Ludwig. Structural balance: a dynamic perspective. Jour-

nal of Mathematical Sociology, 33:129–155, 2009.

[2] E. Balas and C.S. Yu. Finding a maximum clique in an arbitrary graph.

SIAM Journal on Computing, 14:1054–1068, 1986.

[3] N. Bansal, A. Blum, and S. Chawla. Correlation clustering. In Proceedings
of the 43rd annual IEEE symposium of foundations of computer science,
pages 238–250, Vancouver, Canada, 2002.

[4] F. Barahona and A.R. Mahjoub. On the cut polytope. Mathematical Pro-

gramming, 36:157–173, 1986.

[5] F. Barahona and A.R. Mahjoub. Facets of the balanced (acyclic) induced

subgraph polytope. Mathematical Programming, 45:21–33, 1989.

[6] J.J. Barthold. A good submatrix is hard to ﬁnd. Operations Research

Letters, 1:190–193, 1982.

[7] B. DasGupta, G. A. Encisob, E. Sontag, and Y. Zhanga. Algorithmic and
complexity results for decompositions of biological networks into monotone
subsystems. BioSystems, 90:161–178, 2007.

[8] P. Doreian and A. Mrvar. A partitioning approach to structural balance.

Social Networks, 18:149–168, 1996.

[9] P. Doreian and A. Mrvar. Partitioning signed social networks. Social Net-

works, 31:1–11, 2009.

[10] R. Figueiredo and Y. Frota. The maximum balanced subgraph of a signed

graph: applications and solution approaches. Paper submitted, 2012.

[11] R. Figueiredo, M. Labb´e, and C.C. de Souza. An exact approach to the
problem of extracting an embedded network matrix. Computers & Opera-
tions Research, 38:1483–1492, 2011.

[12] N. G¨ulpinar, G. Gutin, G. Mitra, and A. Zverovitch. Extracting pure net-
work submatrices in linear programs using signed graphs. Discrete Applied
Mathematics, 137:359–372, 2004.

[13] F. Harary and J.A. Kabell. A simple algorithm to detect balance in signed

graphs. Mathematical Social Sciences, 1:131–136, 1980.

[14] F. Harary, M. Lim, and D. C. Wunsch. Signed graphs for portfolio analysis
in risk management. IMA Journal of Management Mathematics, 13:1–10,
2003.

[15] F. Huﬀner, N. Betzler, and R. Niedermeier. Separator-based data reduction
for signed graph balancing. Journal of Combinatorial Optimization, 20:335–
360, 2010.

11

[16] T. Inohara. On conditions for a meeting not to reach a deadlock. Applied

Mathematics and Computation, 90:1–9, 1998.

[17] K.T. Macon, P.J. Mucha, and M.A. Porter. Community structure in the
united nations general assembly. Physica A: Statistical Mechanics and its
Applications, 391:343–361, 2012.

[18] M. Padberg. On the facial structure of set packing polyhedra. Mathematical

Programming, 5:199–215, 1973.

[19] S. Rebennack. Encyclopedia of optimization. Springer, 2008.

[20] V.A. Traag and J. Bruggeman. Community detection in networks with

positive and negative links. Physical Review E, 80:036115, 2009.

[21] B. Yang, W.K. Cheung, and J. Liu. Community mining from signed so-
cial networks. IEEE Transactions on Knowledge and Data Engineering,
19:1333–1348, 2007.

[22] T. Zaslavsky. A mathematical bibliography of signed and gain graphs and

allied areas. Electronic Journal of Combinatorics DS8, 1998.

12

