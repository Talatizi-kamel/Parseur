The Thirty-Second AAAI Conference
on Artificial Intelligence (AAAI-18)

Exact Clustering via Integer Programming

and Maximum Satisﬁability

Atsushi Miyauchi,1 Tomohiro Sonobe,2, 3 Noriyoshi Sukegawa4

1RIKEN AIP, Tokyo, Japan

2National Institute of Informatics, Tokyo, Japan

3JST, ERATO, Kawarabayashi Large Graph Project, Tokyo, Japan

4Chuo University, Tokyo, Japan

atsushi.miyauchi.hv@riken.jp, tomohiro sonobe@nii.ac.jp, sukegawa.15k@g.chuo-u.ac.jp

Abstract

We consider the following general graph clustering problem:
given a complete undirected graph G = (V, E, c) with an
edge weight function c : E → Q, we are asked to ﬁnd a
partition C of V that maximizes the sum of edge weights
within the clusters in C. Owing to its high generality, this
problem has a wide variety of real-world applications, includ-
ing correlation clustering, group technology, and community
detection. In this study, we investigate the design of mathe-
matical programming formulations and constraint satisfaction
formulations for the problem. First, we present a novel inte-
ger linear programming (ILP) formulation that has far fewer
constraints than the standard ILP formulation by Gr¨otschel
and Wakabayashi (1989). Second, we propose an ILP-based
exact algorithm that solves an ILP problem obtained by mod-
ifying our above ILP formulation and then performs simple
post-processing to produce an optimal solution to the original
problem. Third, we present maximum satisﬁability (MaxSAT)
counterparts of both our ILP formulation and ILP-based exact
algorithm. Computational experiments using well-known real-
world datasets demonstrate that our ILP-based approaches and
their MaxSAT counterparts are highly effective in terms of
both memory efﬁciency and computation time.

1

Introduction

Clustering is a fundamental tool in data analysis. Roughly
speaking, the task of clustering is to divide a given set of
objects into subsets of homogeneous objects. To date, vari-
ous problem settings and optimization algorithms have been
extensively studied (Aggarwal and Reddy 2013; Jain, Murty,
and Flynn 1999; Xu and Wunsch 2005).

Let us consider the following general graph clustering
problem. An instance is a complete undirected graph G =
(V, E, c) with an edge weight function c : E → Q, where
Q is the set of rational numbers. For simplicity, we denote
cij = c({i, j}) for each {i, j} ∈ E. The edge weight
cij expresses the degree of preference that i, j ∈ V are
assigned to the same cluster; if cij is positive, we wish
to assign i, j ∈ V to the same cluster, whereas if cij is
negative, we wish to assign i, j ∈ V to different clusters.
The goal is to ﬁnd a partition C = {V1, V2, . . . , Vk} (i.e.,
Copyright c(cid:3) 2018, Association for the Advancement of Artiﬁcial
Intelligence (www.aaai.org). All rights reserved.

1387

(cid:2)k
l=1 Vl = V and Vi ∩ Vj = ∅ for i (cid:6)= j) of V that maxi-
(cid:3)
mizes the sum of edge weights within the clusters in C, i.e.,
{i,j}∈E cijδ(C(i),C(j)), where C(i) is the (unique) cluster
to which i ∈ V belongs and δ is Kronecker’s symbol, which
is equal to 1 if two arguments are the same and 0 otherwise.
Note here that in this problem, there is no restriction on the
number of clusters in the output partition; thus, the algorithms
are allowed to specify the optimal number of clusters endoge-
nously. This problem is known as the clique partitioning prob-
lem (CPP), which was originally introduced by Gr¨otschel and
Wakabayashi (1989). As described in Section 2, the high gen-
erality of CPP leads to a wide variety of real-world applica-
tions, including correlation clustering, group technology, and
community detection. The NP-hardness was demonstrated in
Wakabayashi (1986).

In the ﬁeld of artiﬁcial intelligence, mathematical pro-
gramming and constraint satisfaction are known to be key
frameworks to solve NP-hard optimization problems. In these
frameworks, we ﬁrst formulate a problem at hand as a math-
ematical programming problem or a constraint satisfaction
problem such as an integer programming (IP) problem or a
maximum satisﬁability (MaxSAT) problem, and then solve
it using powerful mathematical programming or constraint
satisfaction solvers. For example, in the case of IP problems,
we may use Gurobi Optimizer or IBM ILOG CPLEX. The
problem we address, CPP, is not an exception; in fact, both
of mathematical programming formulations and constraint
satisfaction formulations have been actively developed.

Mathematical programming formulations. Gr¨otschel
and Wakabayashi (1989) introduced a 0-1 integer linear
programming (ILP) formulation for CPP, which has been
employed by many algorithms for CPP and its variants
(e.g., (Agarwal and Kempe 2008; Bruckner et al. 2013;
Jaehn and Pesch 2013; Miyauchi and Miyamoto 2013;
Nowozin and Jegelka 2009; Oosten, Rutten, and Spieksma
2001; Van Gael and Zhu 2007)). The ILP formulation is
simple and intuitive, but not sufﬁciently scalable for real-
world applications in terms of both memory requirements
and computation time. In particular, the issue of memory
requirements is quite serious. Letting n = |V |, the ILP for-
= Θ(n3) constrains, which grows rapidly
mulation has 3
as n increases. For example, if n = 1,000, the number of con-

(cid:4)

(cid:5)

n
3

straints reaches the order of half a billion; it is quite difﬁcult
to store such an ILP formulation on a standard computer.

To overcome this issue, much effort has been dedicated
to constructing ILP formulations for CPP with fewer con-
straints. Dinh and Thai (2015) addressed a special case of
CPP, which is called the modularity maximization prob-
lem (Fortunato 2010; Newman and Girvan 2004), and de-
rived a set of redundant constraints in the ILP formulation
by Gr¨otschel and Wakabayashi (1989). By removing the con-
straints in advance, they introduced an ILP formulation with
fewer constraints for the special case. Recently, Miyauchi
and Sukegawa (2015b) generalized Dinh and Thai’s result to
CPP. If m≥0 denotes the number of nonnegative-weighted
edges in G, i.e., m≥0 = |{{i, j} ∈ E : cij ≥ 0}|, the
ILP formulation by Miyauchi and Sukegawa (2015b) has
O(nm≥0) constraints, which improves on the ILP formula-
tion by Gr¨otschel and Wakabayashi (1989) for the case in
which m≥0 is not large (e.g., m≥0 = O(n)).

However, for most real-world instances of CPP, the pa-
rameter m≥0 is large owing to the large number of edges
with weight zero; thus, the beneﬁt of the above reformulation
is quite limited for real-world applications. In fact, com-
putational experiments in Miyauchi and Sukegawa (2015b)
demonstrated that the decrease in the number of constraints—
which is about 20% at most—is not signiﬁcant. Moreover,
their reformulation does not reduce computation time signiﬁ-
cantly; in fact, in some cases computation time increases.

Constraint
satisfaction formulations. Very recently,
Berg and J¨arvisalo (2017) developed MaxSAT formulations
for an optimization problem called the weighted correlation
clustering problem (WCC). It should be noted that WCC is
equivalent to CPP from an exact optimization perspective
(see Example 1 in Section 2). Thus, the MaxSAT formula-
tions by Berg and J¨arvisalo (2017) for WCC can be seen as
exact formulations for CPP. WCC and its variants have been
actively studied in the ﬁeld of artiﬁcial intelligence (Ahn
et al. 2015; Awasthi, Balcan, and Voevodski 2014; Bansal,
Blum, and Chawla 2004; Bonchi, Gionis, and Ukkonen 2013;
Chierichetti, Dalvi, and Kumar 2014; Kim et al. 2014;
Puleo and Milenkovic 2016; Van Gael and Zhu 2007).

Speciﬁcally, Berg and J¨arvisalo (2017) developed three
MaxSAT formulations: MaxSAT-Transitive, MaxSAT-Unary,
and MaxSAT-Binary. MaxSAT-Transitive is the MaxSAT coun-
terpart of the ILP formulation by Gr¨otschel and Wak-
abayashi (1989). MaxSAT-Unary and MaxSAT-Binary are
MaxSAT formulations that employ the unary encoding and bi-
nary encoding techniques, respectively. In their experiments,
the MaxSAT formulations were compared with the ILP for-
mulation by Gr¨otschel and Wakabayashi (1989). The results
of their experiments showed that MaxSAT-Binary outperforms
both the other MaxSAT formulations and the ILP formulation.
Thus, MaxSAT-Binary is known to be state-of-the-art in terms
of exact formulation for WCC and thus for CPP.

1.1 Our Contribution
In this study, we further investigate the design of mathemat-
ical programming formulations and constraint satisfaction

1388

formulations for CPP. Our contribution can be summarized
as follows:
1. We present a novel ILP formulation for CPP in which
the number of constraints is O(nm>0), where m>0 is
the number of positive-weighted edges in G, i.e., m>0 =
|{{i, j} ∈ E : cij > 0}|.

2. We also propose an ILP-based exact algorithm for CPP.
The algorithm ﬁrst solves an ILP problem obtained by
modifying our above ILP formulation and then performs
simple post-processing to obtain an optimal solution to
CPP.

3. We present MaxSAT counterparts of both our ILP formu-

lation and ILP-based exact algorithm.

4. We conduct thorough experiments to evaluate the effec-
tiveness of our ILP-based approaches and their MaxSAT
counterparts in terms of both memory efﬁciency and com-
putation time.
We ﬁrst describe our ﬁrst result above in detail. To design
our ILP formulation, we effectively use the above result by
Miyauchi and Sukegawa (2015b). Recall that they proposed
an ILP formulation for CPP that has O(nm≥0) constraints.
The serious problem with their formulation is that for most
real-world instances of CPP, the parameter m≥0 is large
owing to the large number of edges with weight zero. The
critical idea behind the design of our ILP formulation is to
perturb the edge weight function of a given instance so that
all edges with weight zero have some negative weight. By
doing this, the resulting instance has small m≥0; thus, the
ILP formulation by Miyauchi and Sukegawa (2015b) for the
resulting instance, which is our proposed ILP formulation for
the original instance, has far fewer constraints. Our theoreti-
cal analysis demonstrates that if the negative values used for
the perturbation are close to zero, the proposed formulation
obtains an optimal solution to the original instance.

We describe our second result in detail. In our ILP for-
mulation above, it is necessary to deal with some negative
perturbation values very close to zero. Unfortunately, such
values may cause numerical instability and therefore increase
computation time in practice; hence, such perturbation should
be avoided if possible. To this end, we introduce an ILP prob-
lem that is identical to our above ILP formulation for CPP
except that it uses an unperturbed objective function. This
modiﬁed ILP problem also has O(nm>0) constraints but
does not depend on the perturbation. However, the ILP prob-
lem itself is incomplete as an ILP formulation for CPP; in
fact, an optimal solution to the ILP problem may be infeasi-
ble for CPP. Thus, to obtain an optimal solution to CPP, the
algorithm also performs simple post-processing that runs in
linear time.

We next describe our third result in detail. As mentioned
above, Berg and J¨arvisalo (2017) introduced a MaxSAT for-
mulation called MaxSAT-Transitive, which is the MaxSAT
counterpart of the ILP formulation by Gr¨otschel and Wak-
abayashi (1989). That is, MaxSAT-Transitive uses hard clauses
to represent the constraints in the ILP formulation and soft
clauses associated with appropriate weights to represent its
objective function. Beginning with MaxSAT-Transitive, we

can reproduce our results for ILP in the context of MaxSAT;
speciﬁcally, we can obtain MaxSAT counterparts of both our
ILP formulation and ILP-based exact algorithm.

Finally, we describe our fourth result in detail. In a series
of experimental assessments, we compare our ILP-based ap-
proaches and their MaxSAT counterparts with the previous
formulations using well-known real-world datasets arising
in the context of correlation clustering, group technology,
and community detection. The results demonstrate that our
approaches signiﬁcantly outperform the state-of-the-art for-
mulations in terms of both memory efﬁciency and computa-
tion time. In particular, our ILP-based approaches can solve
a real-world instance with a few thousand vertices for which
the ILP formulation by Gr¨otschel and Wakabayashi (1989)
has more than eight billion constraints.

2 Application Examples

CPP is a general clustering problem and therefore has a wide
variety of applications. Here we provide some important
application examples.
Example 1 (Correlation clustering). Correlation clustering
was introduced by Bansal, Blum, and Chawla (2004) for
clustering with qualitative information. As an example, we
consider document clustering, in which a set of documents is
to be clustered into topics, with the hindering constraint that
there is no exact prior deﬁnition of what a “topic” constitutes.
Alternatively, it can be assumed that there exists qualitative
similarity information indicating that a number of pairs of
documents are similar or dissimilar. In such a situation, the
goal of correlation clustering is to ﬁnd a partition of the set of
documents that agrees as much as possible with the similarity
information.
A mathematical formulation of correlation clustering is as
follows: Let G(cid:4) = (V (cid:4), E+, E−) be an edge-labeled undi-
rected graph in which each edge e ∈ E+ is labeled as “+”
(similar) and each edge e ∈ E− is labeled as “−” (dissim-
ilar). Note that E+ ∩ E− = ∅ holds. The maximization
version, MAXAGREE, asks for a partition C of V (cid:4) that max-
imizes agreements (the number of + edges within clusters
plus the number of − edges across clusters). The minimiza-
tion version, MINDISAGREE, asks for a partition C of V (cid:4)
that minimizes disagreements (the number of − edges within
clusters plus the number of + edges across clusters). These
problems are equivalent in terms of optimality and are both
NP-hard (Bansal, Blum, and Chawla 2004). WCC, which was
mentioned above, deals with edge-weighted generalizations
of both MAXAGREE and MINDISAGREE.

MAXAGREE and MINDISAGREE can be reduced to CPP.
An instance G = (V, E, c) of CPP is constructed as fol-
lows: Let V = V (cid:4). For each {i, j} ∈ E, we set cij = 1 if
{i, j} ∈ E+, cij = −1 if {i, j} ∈ E−, and cij = 0 other-
wise. Clearly, an optimal solution to CPP corresponds to an
optimal solution to both MAXAGREE and MINDISAGREE. It
should be noted that WCC can also be reduced to CPP and
CPP can be reduced to WCC.
Example 2 (Group technology). Group technology plays
a key role in the design of efﬁcient manufacturing sys-

1389

tems (Groover 2007). Suppose that the goal is to develop
a manufacturing system for some new product, comprising p
parts that are processed by q machines. In such a situation,
the goal of group technology is to ﬁnd a suitable partition of
the set of parts and machines needed to deﬁne an efﬁcient
cellular manufacturing system.

As mentioned in Oosten, Rutten, and Spieksma (2001),
group technology can be modeled as CPP. An instance G =
(V, E, c) of CPP is constructed as follows: Let V be a union
of the set of p parts and the set of q machines. An edge
{i, j} ∈ E between a part i and a machine j has weight 1 if i
is processed by j and −1 otherwise. Each edge between two
parts or two machines has weight zero.
Example 3 (Community detection). Community detection
is a fundamental task in network analysis that aims to ﬁnd
a partition of the set of vertices into communities (Fortu-
nato 2010). Intuitively speaking, a community is a subset
of vertices densely connected internally but sparsely con-
nected with the rest of the network. Recently, the issue of
community detection in bipartite networks has garnered a
signiﬁcant amount interest (Fortunato 2010). Barber (2007)
introduced a quality function called the bipartite modular-
ity, which is appropriate for community detection in bipar-
tite networks. Let G(cid:4) = (V (cid:4), E(cid:4)) be an undirected bipar-
tite graph for which it is known that V (cid:4) is divided into
R so that each edge has one endpoint in V (cid:4)
L and V (cid:4)
V (cid:4)
L and
the other in V (cid:4)
(cid:3)
(cid:3)
R. The bipartite modularity, a quality func-
tion for a partition C of V (cid:4), can be written as Qb(C) =
δ(C(i),C(j)), where Aij
1|E(cid:2)|
is the (i, j) component of the adjacency matrix of G(cid:4) and di is
the degree of i ∈ V (cid:4). The bipartite modularity maximization
problem is NP-hard (Miyauchi and Sukegawa 2015a).
The problem can be reduced to CPP. An instance G =
(V, E, c) of CPP is constructed as follows: Let V = V (cid:4). An
edge {i, j} ∈ E between i ∈ V (cid:4)
R has weight
|E(cid:2)| − didj
L or two
vertices in V (cid:4)

|E(cid:2)|2 . Each edge between two vertices in V (cid:4)

L and j ∈ V (cid:4)

Aij − didj
|E(cid:2)|

R has weight zero.

j∈V (cid:2)

i∈V (cid:2)

(cid:6)

(cid:7)

Aij

R

L

3

ILP Formulation

We ﬁrst revisit the standard formulation by Gr¨otschel and
Wakabayashi (1989) and the reformulation by Miyauchi and
Sukegawa (2015b). Let V = {1, 2, . . . , n} and P = {(i, j) :
1 ≤ i < j ≤ n}. For each (i, j) ∈ P , we introduce a decision
variable xij equal to 1 if i, j ∈ V are in the same cluster and
0 otherwise. Then the ILP formulation by Gr¨otschel and
Wakabayashi (1989) can be represented as follows:

(cid:8)

P(G) : max.

s. t.

cijxij

(i,j)∈P
xij + xjk − xik ≤ 1 ∀(i, j, k) ∈ T,
xij − xjk + xik ≤ 1 ∀(i, j, k) ∈ T,
−xij + xjk + xik ≤ 1 ∀(i, j, k) ∈ T,
∀(i, j) ∈ P,
xij ∈ {0, 1}

where T = {(i, j, k) : 1 ≤ i < j < k ≤ n}. The triangle
inequality constraints stipulate that for any i, j, k ∈ V , if

(cid:5)

(cid:4)

i, j ∈ V are in the same cluster and j, k ∈ V are also in
(cid:5)
the same cluster, then i, k ∈ V must be in the same cluster.
=
The ILP formulation has
Θ(n3) triangle inequality constraints.

= Θ(n2) variables and 3

Miyauchi and Sukegawa (2015b) derived a set of redun-
dant triangle inequality constraints in P(G). By removing
the constraints in advance, they introduced the following ILP
formulation:

(cid:4)

n
2

n
3

(cid:8)

RP(G) : max.

cijxij

s. t.

(i,j)∈P
xij + xjk − xik ≤ 1 ∀(i, j, k) ∈ T 1≥0,
xij − xjk + xik ≤ 1 ∀(i, j, k) ∈ T 2≥0,
−xij + xjk + xik ≤ 1 ∀(i, j, k) ∈ T 3≥0,
xij ∈ {0, 1}

∀(i, j) ∈ P,

where T 1≥0 = {(i, j, k) ∈ T : cij ≥ 0 or cjk ≥ 0}, T 2≥0 =
{(i, j, k) ∈ T : cij ≥ 0 or cik ≥ 0}, and T 3≥0 = {(i, j, k) ∈
T : cjk ≥ 0 or cik ≥ 0}. They proved the following theorem:
Theorem 1 (Theorem 1 in Miyauchi and Sukegawa (2015b)).
Let G = (V, E, c) be an arbitrary instance of CPP. P(G) and
RP(G) share the same set of optimal solutions.

Therefore, we can solve RP(G) instead of P(G) to ob-
tain an optimal solution to CPP. Note that the number of
triangle inequality constraints in RP(G) can be evaluated
as O(nm≥0), where m≥0 is the number of nonnegative-
weighted edges in G, i.e., m≥0 = |{(i, j) ∈ P : cij ≥ 0}|.

n
2

cij

(cid:9)cij =
(cid:5)
(cid:4)

3.1 Our Formulation
Here we present our ILP formulation. Without loss of gen-
erality, we assume that the edge weight function c is integer-
valued. When c is rational-valued, we can immediately obtain
an equivalent instance in which c is integer-valued by multi-
plying an appropriate value for each cij.
weight function(cid:9)c so that for each {i, j} ∈ E,
Let E0 = {{i, j} ∈ E : cij = 0}. We deﬁne an edge
if {i, j} ∈ E0,
otherwise,

(cid:10) −(cid:3)
). Let us introduce a new instance (cid:9)G =
(V, E,(cid:9)c). Then the number of triangle inequality constraints
where (cid:3) ∈ (0, 1/
in RP((cid:9)G) is O(nm>0), where m>0 is the number of positive-
weighted edges in G, i.e., m>0 = |{(i, j) ∈ P : cij > 0}|.
solution to RP((cid:9)G) is also optimal to RP(G) and thus to P(G).
It is expected that as (cid:3) > 0 is sufﬁciently small, an optimal
RP((cid:9)G) is also optimal to P(G).
Proof. Let (cid:9)x = ((cid:9)xij)(i,j)∈P be an arbitrary optimal solution
to RP((cid:9)G). From Theorem 1, (cid:9)x is an optimal solution to
P((cid:9)G), which implies that(cid:9)x satisﬁes all the triangle inequality
constraints for T . Thus, (cid:9)x is also feasible for P(G).

In fact, we have the following theorem:
Theorem 2. Let G = (V, E, c) be an arbitrary instance of
CPP such that c is integer-valued. Any optimal solution to

(cid:4)

(cid:3)

(xij)(i,j)∈P be an optimal solution to P(G) and a its objective

We now show the optimality of (cid:9)x to P(G). Let x =
value in P(G). Since all the constraints in RP((cid:9)G) are also con-
tained in P(G), the solution x is feasible for RP((cid:9)G). The ob-
jective value of x in RP((cid:9)G), i.e.,
(i,j)∈P (cid:9)cijxij, is strictly
from P(G) to RP((cid:9)G), of the objective value of x is at most
greater than a − 1 because the decrement, due to the change
(cid:5)
(cid:5)(cid:5)·(cid:4)
(cid:4)
= 1. As for the objective value of(cid:9)x in
(cid:3)
(i,j)∈P cij(cid:9)xij, we have a ≥(cid:3)
(i,j)∈P cij(cid:9)xij ≥
(cid:3)·|E0| <
(i,j)∈P (cid:9)cij(cid:9)xij ≥(cid:3)
(cid:3)
(i,j)∈P (cid:9)cijxij > a − 1, where the ﬁrst
P(G), i.e.,
inequality follows from the feasibility of (cid:9)x in P(G), and the
(cid:9)x and x, respectively, in RP((cid:9)G). Since the objective value
(cid:3)
of (cid:9)x in P(G) is an integer, we have
(i,j)∈P cij(cid:9)xij = a.
Therefore, (cid:9)x is optimal to P(G).

third inequality follows from the optimality and feasibility of

1/

n
2

n
2

4

ILP-Based Exact Algorithm

We introduce the following ILP problem:

∗(G) : max.

RP

cijxij

(cid:8)

s. t.

(i,j)∈P
xij + xjk − xik ≤ 1 ∀(i, j, k) ∈ T 1
>0,
xij − xjk + xik ≤ 1 ∀(i, j, k) ∈ T 2
>0,
−xij + xjk + xik ≤ 1 ∀(i, j, k) ∈ T 3
>0,
xij ∈ {0, 1}

Unfortunately, RP

∀(i, j) ∈ P,
>0 = {(i, j, k) ∈ T : cij > 0 or cjk > 0}, T 2
where T 1
>0 =
{(i, j, k) ∈ T : cij > 0 or cik > 0}, and T 3
>0 = {(i, j, k) ∈
is the same as in RP((cid:9)G), whereas the objective function is
T : cjk > 0 or cik > 0}. Note here that the set of constraints
the same as in P(G) and RP(G), i.e., the unperturbed one.
∗(G) may fail to obtain an optimal
solution to P(G). In fact, there exist instances such that
∗(G) is infeasible for P(G). For
an optimal solution to RP
example, consider G = (V, E, c) with V = {1, 2, 3, 4},
c12 = 1, c13 = c23 = −1, and c14 = c24 = c34 = 0.
A 0-1 vector x∗ = (x∗
ij) such that x∗
24 =
x∗
34 = 1 and x∗
13 = x∗
23 = 0 is one of the optimal solu-
∗(G); however, the triangle inequality constraint
tions to RP
−x13 + x34 + x14 ≤ 1 in P(G) is violated.
To obtain an optimal solution to P(G), we perform the
following simple post-processing, which we refer to as pp,
>0 = {(i, j) ∈
for an optimal solution x∗
ij = 1, cij > 0}. Obtain a set of weakly connected
P : x∗
components {V1, V2, . . . , Vk} of (V, P ∗
>0) by the depth-ﬁrst
search. Output a 0-1 vector x∗ that corresponds to the parti-
tion {V1, V2, . . . , Vk}, i.e., x∗ such that x∗
ij = 1 if and only
if i, j ∈ Vq for some q ∈ {1, 2, . . . , k}. Note that pp runs in
time linear in the size of G.

∗(G): Let P ∗

12 = x∗

14 = x∗

to RP

4.1 Correctness
∗(G)+pp)
Here we demonstrate that our algorithm (i.e., RP
returns an optimal solution to P(G). To this end, it sufﬁces

1390

to show that the objective value of x∗ remains the same as
∗(G)) because x∗ is feasible for
that of x∗
(in P(G) and RP
∗(G) of P(G). For
P(G) and x∗
in = {(i, j) ∈ P : x∗
ij = 1} and
convenience, we deﬁne P ∗
(cid:8)
(cid:8)
out = P \ P ∗
P ∗
in. We have the following lemmas:
Lemma 1. It holds that

is optimal to a relaxation RP

cijx∗
ij.

cijx∗

ij =

(i,j)∈P ∗

in

(i,j)∈P ∗

in

+ xv1v2

− xv0v2

> 0 (and cv1v2

Proof. It sufﬁces to show that for any q ∈ {1, 2, . . . , k},
ij = 1 for each i, j ∈ Vq with i < j. Fix
it holds that x∗
q ∈ {1, 2, . . . , k}. Let i, j be a pair of distinct vertices of Vq.
Since Vq is weakly connected by P ∗
>0, there exists a path on
P ∗
>0 that connects i and j if we ignore the direction of edges.
Denote this (undirected) path by i = v0, v1, . . . , vt = j.
∗(G) has the constraint
Since cv0v1
≤ 1. Note here that in this notation,
xv0v1
it is necessary that v0 < v1 < v2 holds. If it is not the
case, we should swap the order of the indices appropriately.
Substituting x∗
= 1 to this constraint, we have
∗(G) also has the
x∗
= 1. Moreover, since cv2v3
> 0, RP
− xv0v3
≤ 1. Substituting x∗
v0v2
constraint xv0v2
=
= 1 to this constraint, we have x∗
x∗
= 1. Repeating
(cid:8)
= x∗
this operation, we ﬁnally have x∗
v0v3
v2v3
ij = 1.
ij ≤ 0.

Lemma 2. It holds that

> 0), RP

+ xv2v3

cijx∗

= x∗

v0v2

v0v1

v1v2

v0vt

ij = 1 and thus (i, j) ∈ P ∗

out

(i,j)∈P ∗
out, we have (i, j) /∈ P ∗
>0. If other-
in. Therefore, for each
ij = 0 or cij ≤ 0, which proves the

out, we have x∗

Proof. For each (i, j) ∈ P ∗
wise, then x∗
(i, j) ∈ P ∗
lemma.
(cid:3)
(cid:3)

ij ≥(cid:3)

in

(i,j)∈P ∗

By Lemmas 1 and 2, we have
cijx∗
cijx∗
ij +
(i,j)∈P ∗
(i,j)∈P cijx∗

ij =
ij =
ij. Therefore, we have the following theorem:
Theorem 3. Let G = (V, E, c) be an arbitrary instance of
CPP such that c is integer-valued. Any 0-1 vector returned
by our algorithm (i.e., RP

∗(G)+pp) is optimal to P(G).

out

in

(cid:3)
(cid:3)
(i,j)∈P cijx∗
cijx∗
(i,j)∈P ∗

5 MaxSAT Counterparts

formulation (i.e., RP((cid:9)G)) and ILP-based exact algorithm
Here we present MaxSAT counterparts of both our ILP
∗(G)+pp). It should be noted that we here con-
(i.e., RP
sider WCC rather than CPP. As described above, WCC is
equivalent to CPP from an exact optimization perspective.
Let G = (V, E+, E−, c) be an instance of WCC. Note that
c : E+ ∪ E− → Q>0 is an edge weight function, where Q>0
is the set of positive rational numbers. The (positive) edge
weights represent the strength of similarity and dissimilarity
for {i, j} ∈ E+ and {i, j} ∈ E−, respectively. For simplic-
ity, we denote cij = c({i, j}) for each {i, j} ∈ E+ ∪ E−.
We revisit MaxSAT-Transitive introduced by Berg and
J¨arvisalo (2017), which is the MaxSAT counterpart of P(G).
Let V = {1, 2, . . . , n} and P = {(i, j) : 1 ≤ i < j ≤ n}.
For each (i, j) ∈ P , we introduce a Boolean variable xij
equal to True if i, j ∈ V are in the same cluster and False

1391

otherwise. Then MaxSAT-Transitive, which we refer to as
S-P(G) in the present study, can be represented as follows:

∀(i, j, k) ∈ T,
∀(i, j, k) ∈ T,
∀(i, j, k) ∈ T,

Hard clauses:
(¬xij ∨ ¬xjk ∨ xik)
(¬xij ∨ xjk ∨ ¬xik)
(xij ∨ ¬xjk ∨ ¬xik)
Soft clauses:
∀(i, j) ∈ P with {i, j} ∈ E+,
(xij) with weight cij
(¬xij) with weight cij ∀(i, j) ∈ P with {i, j} ∈ E−,
where T = {(i, j, k) : 1 ≤ i < j < k ≤ n}. The set of
hard clauses is a clausal representation of the set of triangle
inequality constraints in P(G), and the set of soft clauses is a
clausal representation of the objective function in P(G).

tain S-RP(G), S-RP((cid:9)G), and S-RP
MaxSAT counterparts of RP(G), RP((cid:9)G), and RP

By beginning with S-P(G), we can reproduce our results
for ILP in the context of MaxSAT; speciﬁcally, we can ob-
∗(G)+S-pp, which are the
∗(G)+pp,
respectively. The detailed description of them is omitted ow-
ing to space limitations. We have the following theorems:
Theorem 4 (MaxSAT counterpart of Theorem 2). Let G =
(V, E+, E−, c) be an arbitrary instance of WCC such that c

is integer-valued. Any optimal solution to S-RP((cid:9)G) is also

optimal to S-P(G).
Theorem 5 (MaxSAT counterpart of Theorem 3). Let G =
(V, E+, E−, c) be an arbitrary instance of WCC such that c
is integer-valued. Any True-False assignment returned by
∗(G)+S-pp) is optimal to S-P(G).
our algorithm (i.e., S-RP

6 Experimental Evaluation

The purpose of our experiments is to evaluate the effective-
ness of our ILP-based approaches and their MaxSAT coun-
terparts in terms of both memory efﬁciency and computation
time. To this end, we use well-known real-world datasets aris-
ing in the context of correlation clustering, group technology,
and community detection.

6.1

ILP-Based Approaches

We ﬁrst compare our ILP formulation (i.e., RP((cid:9)G)) and ILP-
∗(G)+pp) with the previous
based exact algorithm (i.e., RP
ILP formulations (i.e., P(G) and RP(G)) and the state-of-
RP((cid:9)G), we set the parameter (cid:3) as follows: (cid:3) = 1
the-art MaxSAT formulation (i.e., MaxSAT-Binary). As for
n2 and
2
n2 , both of which are less than 1/
. All ILP formula-
tions were solved using Gurobi Optimizer 7.0.2 with default
parameters. As for MaxSAT-Binary, we employed the pre-
processing and symmetry-breaking operations mentioned in
Berg and J¨arvisalo (2017). The preprocessing was simulated
using Coprocessor 3.0 and the symmetry-breaking proce-
dure called REMOVESLACK was applied. MaxSAT-Binary
was solved using MaxHS 2.9, as recommended in Berg and
J¨arvisalo (2017).

(cid:4)

(cid:5)

n
2

Table 1: Instances used in our experiments.

n m>0/

m≥0/

ID
Name
P1
Protein1
P2
Protein2
P3
Protein3
P4
Protein4
G9
Ch-8x20b
G14 Mc-16x24
G16 KI-16x43
G17 Ca-18x24
G18 MT-20x20
G19 Ku-20x23
G21 Bo-20x35
G25 CH5-24x40
G26 CH6-24x40
G27 CH7-24x40
G28 Mc-27x27
G29 Ca-28x46
G30 Ku-30x41
St-30x50-1
G31
G32
St-30x50-2
G33 Ki-36x90
G34 MC-37x53
G35 Ch-40x100
C1 Wafa-CEO
C2
C3
C4
C5
C6

Divorces
Hollywood movies
Scotland interlocks
Graph product
Network science

669
587
567
654
28
40
59
42
40
43
55
64
64
64
54
74
71
80
80
126
90
140
41
59
102
244
674
2,549

(cid:4)

(cid:5)

n
2
4.22%
6.36%
6.39%
2.64%
24.07%
11.47%
7.36%
10.22%
14.23%
12.51%
10.03%
6.50%
6.50%
6.50%
15.30%
7.81%
5.15%
4.87%
5.28%
4.23%
24.39%
4.32%
11.10%
11.63%
3.73%
1.21%
0.27%
0.08%

(cid:4)

(cid:5)

n
2
98.49%
98.21%
97.95%
98.87%
81.75%
61.81%
67.15%
60.05%
62.95%
61.57%
62.90%
58.88%
58.88%
58.88%
64.36%
60.13%
55.65%
57.41%
57.82%
66.41%
75.43%
63.21%
63.54%
85.33%
56.79%
59.00%
50.43%
53.11%

The time limit was set to 4 hours and the memory limit was
set to 96 GB. The experiments were conducted on a Linux
machine with Intel Xeon Processor E5-2650 v2 2.60 GHz
CPU and 96 GB RAM.

n
2

(cid:5)

(cid:4)

Correlation clustering. Correlation clustering instances
were ﬁrst tested. Speciﬁcally, we considered MAXAGREE in
the edge-weighted setting (i.e., WCC). The upper section of
Table 1 lists the instances on which experiments were con-
ducted, which were generated from protein sequence datasets
on http://www.paccanarolab.org/scps in the same
manner as in Berg and J¨arvisalo (2017). The data consist of
similarity values between amino-acid sequences that were
computed using BLAST (Altschul et al. 1990).

ables is always equal to
constraints in RP

The results are detailed in Table 2. The number of vari-
= n(n − 1)/2. The number of
same as in RP((cid:9)G). OM in some columns indicates that the
∗(G) is omitted because it is exactly the

memory requirements of the formulation (and the solving
phase) exceed the limit (i.e., 96 GB). For the formulations
that could be stored on the machine but could not be solved
within the time limit, the relative gaps (i.e., (UB − LB)/LB,
where UB and LB, respectively, are the upper and lower
bounds on the optimal value) obtained by the time limit are
presented within parentheses if they are ﬁnite; otherwise OT
is given. For each instance, the best computation time (or the
relative gap) among the formulations is written in bold.

It is seen that neither P(G) nor RP(G) could be stored on
the machine for instances P1 and P4 owing to a shortage

RP((cid:9)G) and RP

of memory capacity. Although RP(G) had fewer constraints
than P(G), the decrement was quite small, with at most 0.1%
of the constraints removed. By contrast, our formulations,
∗(G), had far fewer constraints, with about
90% of the constraints removed. Correspondingly, the mem-
ory limit was not exceeded, and optimal solutions were ob-
tained for instances P1 and P2. The results also show that
our formulations outperformed MaxSAT-Binary. In fact, only
∗(G)+pp could obtain an optimal solution to
instance P2 and nearly-optimal solutions for instances P3 and
P4, although MaxSAT-Binary solved instance P1 faster.

RP((cid:9)G) and RP

Group technology. An assessment of group technology
instances was then conducted; some of these are listed
in the middle section of Table 1. The instances were
generated from manufacturing cell formation datasets on
http://mauricio.resende.info/data in the manner
described in Example 2; a detailed description of the datasets
can be found in Gonc¸alves and Resende (2004). Although
there were originally 35 instances, which were indexed from
G1 to G35, some instances are omitted owing to space limi-
tations. Our preliminary experiments showed that all formu-
lations could solve the omitted instances within 10.0 s.

instances. Again, our formulations, RP((cid:9)G) and RP

The results are summarized in Table 2. Because the in-
stances are smaller than those used in correlation clustering,
P(G) and RP(G) could always be stored on the machine.
Although RP(G) had fewer constraints than P(G), the com-
putation time (or the relative gap) increased in 7 out of 17
∗(G), pro-
duced far fewer constraints. In fact, even for relatively small
instances, at least 50% of the constraints were removed, with
the ﬁgure increasing to above 90% for some large instances.
Furthermore, the computation time was reduced signiﬁcantly.
∗(G)+pp could obtain optimal solutions for
In particular, RP
all instances within the time limit. The results also show that
MaxSAT-Binary performed no better than P(G) and RP(G).
In fact, for any instance that could not be solved by P(G)
and RP(G), MaxSAT-Binary also failed to obtain an optimal
solution, and moreover, only MaxSAT-Binary exceeded the
memory limit for some instances owing to its signiﬁcant
memory requirements in the search phase.

Community detection. Community detection instances
were then tested, with particular consideration given to the
bipartite modularity maximization problem. The last section
of Table 1 lists the instances on which experiments were
conducted, which were generated from network datasets on
http://vlado.fmf.uni-lj.si/pub/networks/data
in the manner described in Example 3.

The results are detailed in Table 2. It is seen that the trend
clustering and group technology assessments, i.e., RP((cid:9)G)
of the results is similar to that produced in the correlation
∗(G)+pp outperformed P(G), RP(G), and MaxSAT-
and RP
Binary. Most strikingly, our approaches could obtain an opti-
mal solution to instance C6 with 2,549 vertices, while P(G)
and RP(G) required more than 8 billion and 6 billion con-
straints, respectively. Furthermore, MaxSAT-Binary left a very
large relative gap (i.e., 6,350.3%).

1392

RP((cid:9)G)

Table 2: Results for the previous ILP formulations, our ILP-based approaches, and the state-of-the-art MaxSAT formulation.

ID

P1
P2
P3
P4
G14
G16
G17
G18
G19
G21
G25
G26
G27
G28
G29
G30
G31
G32
G33
G34
G35
C1
C2
C3
C4
C5
C6

P(G)

RP(G)

time(s)

time(s)

#constr.
#constr.
#constr.
OM 12,106,852
OM 148,995,305
149,038,482
12,191,742
OT
OM 100,571,045
100,614,735
OT
10,995,760
OT
90,611,160
90,660,465
OM 7,161,805
OM 139,199,019
139,222,212
5,902
17.0
23,366
20.8
27,417
13,560
551.1
84,297
233.3
97,527
6,640
14.0
28,920
18.4
34,440
7,839
803.9
25,661
804.4
29,640
52.4
8,646
66.6
31,606
37,023
14,938
149.2
67,196
126.8
78,705
15,750
245.2
102,860
474.5
124,992
15,765
418.3
102,875
426.8
124,992
15,777
1,145.3
102,887
1,338.4
124,992
21,044
1,419.3
65,114
2,426.5
74,412
(8.5%)
28,840
(6.4%)
161,752
194,472
17,222
30.7
137,420
29.8
171,465
23,508
85.0
199,476
78.4
246,480
25,405
200,359
246,480
4,556.4
2,634.1
68,435
716,019 (132.1%)
842,520 (151.3%)
352,440
(13.2%)
326,247
(82.9%)
146,067
112,904
13.4
1,121,684
16.3
1,342,740
6,640
41.4
27,466
54.8
31,980
20,116
4,749.9
93,475
4,927.8
97,527
37,470
(11.8%)
413,487
(11.6%)
515,100
7,174,332
(8.4%)
5,840,182
(8.4%)
172,070
OM
OM 114,839,168
152,410,272
822,272
8.3G
OM
6.3G
OM 13,130,379

(cid:3) = 1
n2
time(s)
4,010.3
2,774.3
(0.3%)
(0.2%)
4.2
14.2
5.2
433.6
18.9
21.0
16.6
62.2
227.2
1,322.7
1,596.3
4.7
10.7
127.0
(6.0%)
5,968.0
1.3
9.4
75.6

(cid:3) = 2
n2
time(s)
3,505.6
3,430.9
(0.3%)
(0.2%)
4.6
13.9
4.8
343.6
18.6
21.2
12.9
61.1
258.1
1,193.3
1,715.2
6.2
12.0
107.8
(6.7%)
7344.6
1.3
10.4
74.5
8,711.4 10,821.9
(1.3%)
(1.9%)
15.9
16.2
397.2
407.3

RP

∗(G)+pp
time(s)
3,796.2
3,039.9
(0.3%)
(0.2%)
4.2
12.4
3.2
273.9
14.4
19.1
14.7
25.5
168.9
570.1
1,296.5
4.3
10.6
47.0
11,963.4
4,131.6
1.3
7.5
64.8
(0.4%)
(1.5%)
18.2
402.4

MaxSAT-Binary

time(s)
#var.
2,304.8
167,184
(48.1%)
179,968
(18.1%)
173,928
(119.2%)
109,692
12.3
3,412
64.3
6,212
12.5
3,960
OM
3,680
219.5
4,196
182.2
6,260
110.4
9,536
(1.4%)
9,536
(160.6%)
9,536
OM
6,480
OM
12,628
12.3
12,064
14.9
14,620
(137.2%)
14,620
OM
25,980
(149.5%)
18,909
17.8
42,240
14.1
3,612
138.9
4,308
OM
23,190
(141.9%)
129,024
1,369,960
4,994.9
21,417,336 94,669,067 (6,350.3%)

#clauses
684,568
744,956
719,876
434,570
12,120
22,440
14,122
12,962
15,128
22,856
31,718
31,718
31,718
23,758
48,267
46,280
55,683
55,683
100,201
73,342
168,918
12,952
15,232
90,651
527,718
5,888,398

6.2 MaxSAT Counterparts

Next we compare our MaxSAT formulation (i.e., S-RP((cid:9)G))
∗(G)+S-pp)
and MaxSAT-based exact algorithm (i.e., S-RP
S-P(G) and S-RP(G)). As for S-RP((cid:9)G), we set the parameter
with the MaxSAT counterparts of P(G) and RP(G) (i.e.,
as in Table 2. As for S-RP((cid:9)G), the left and right columns

(cid:3) as in its ILP counterpart, i.e., (cid:3) = 1
n2 and 2
formulations were solved using MaxHS 2.9.

The results are detailed in Table 3 with the same notations

n2 . All MaxSAT

n2 and (cid:3) = 2

correspond to the results of (cid:3) = 1
n2 , respec-
tively. Note that the number of hard clauses in each MaxSAT
formulation is equal to the number of constraints in its ILP
counterpart (see Table 2). It is seen that our results are still

effective for MaxSAT. In fact, S-RP((cid:9)G) could solve 6 out of
11 instances that could be solved neither by S-P(G) nor by
∗(G) could solve instances P1,
S-RP(G), and moreover, S-RP
P2, and P4 much faster than S-P(G) and S-RP(G).

7 Conclusion

In this study, we have investigated the design of mathematical
programming formulations and constraint satisfaction formu-
lations for CPP. More speciﬁcally, we have presented a novel
ILP formulation, an ILP-based exact algorithm, and their
MaxSAT counterparts. The experimental results demonstrate
that our approaches signiﬁcantly outperform the state-of-the-
art formulations in terms of both memory efﬁciency and
computation time.

1393

Table 3: Results for the MaxSAT counterparts.

S-RP((cid:9)G)

ID

16.6
41.4
11.4

45.4
49.9
46.2
348.5

S-P(G)
time(s)
4,362.6
2,690.6
(11.0%)
6,998.2
14.9
19.6
6.1
(140.0%)
195.7
124.3
31.9
2,017.7
(121.1%)
OM
OM
7.1
8.7
(118.0%)
OM
(164.4%)
14.4
13.8
83.5

S-RP(G)
time(s)
5,284.4
2,779.7
(3.1%) (253.1%)
7,773.0
14.5
20.1
6.2
(140.0%)
198.7
126.6
43.4
1,986.3
(121.1%)

time(s)
time(s)
(0.5%)
(0.7%)
P1
2,049.8 2,366.6
P2
(8.2%)
P3
(31.8%) (31.8%)
P4
18.0
G14
49.0
G16
13.1
G17
3,782.8 3,868.5
G18
50.8
G19
60.2
G21
44.4
G25
484.6
G26
1,615.8 2,338.5
G27
OM 3,995.1 6,949.2
G28
OM 8,658.7 11085.3
G29
6.1
16.8
15.8
G30
9.3
28.2
26.9
G31
772.0
841.4
(118.0%)
G32
OT
OM
OT
G33
OT 13,421.1
(164.4%)
G34
2.4
2.8
11.4
G35
13.4
14.5
18.0
C1
82.9
119.3
C2
87.6
OT
OT
C3 (1,340.7%) (1,340.7%)
(65.8%)
OT
OT
C4
C5
2,794.7
525.7
555.7
OM (18.3%) (25.7%)
C6

(65.8%)
4,162.6
OM

S-RP

∗(G)+S-pp
time(s)
1,058.4
486.0
(3.9%)
3,200.5
21.8
39.2
10.5
(140.0%)
637.7
132.4
32.3
4197.1
(123.7%)
OM
OM
14.7
8.9
11,172.4
OM
(154.9%)
3.1
9.7
106.2
(802.1%)
(75.3%)
268.0
(8.5%)

Gr¨otschel, M., and Wakabayashi, Y. 1989. A cutting plane
algorithm for a clustering problem. Mathematical Program-
ming 45(1–3):59–96.
Jaehn, F., and Pesch, E. 2013. New bounds and constraint
propagation techniques for the clique partitioning problem.
Discrete Applied Mathematics 161(13–14):2025–2037.
Jain, A. K.; Murty, M. N.; and Flynn, P. J. 1999. Data
clustering: A review. ACM Computing Surveys 31(3):264–
323.
Kim, S.; Yoo, C. D.; Nowozin, S.; and Kohli, P. 2014. Image
segmentation using higher-order correlation clustering. IEEE
Transactions on Pattern Analysis and Machine Intelligence
36(9):1761–1774.
Miyauchi, A., and Miyamoto, Y. 2013. Computing an up-
per bound of modularity. European Physical Journal B
86(7):302.
Miyauchi, A., and Sukegawa, N. 2015a. Maximizing Bar-
ber’s bipartite modularity is also hard. Optimization Letters
9(5):897–913.
Miyauchi, A., and Sukegawa, N. 2015b. Redundant con-
straints in the standard formulation for the clique partitioning
problem. Optimization Letters 9(1):199–207.
Newman, M. E. J., and Girvan, M. 2004. Finding and
evaluating community structure in networks. Physical Review
E 69:026113.
Nowozin, S., and Jegelka, S. 2009. Solution stability in
linear programming relaxations: Graph partitioning and un-
supervised learning. In ICML ’09: Proceedings of the 26th
International Conference on Machine Learning, 769–776.
Oosten, M.; Rutten, J. H. G. C.; and Spieksma, F. C. R. 2001.
The clique partitioning problem: Facets and patching facets.
Networks 38(4):209–226.
Puleo, G. J., and Milenkovic, O. 2016. Correlation clustering
and biclustering with locally bounded errors. In ICML ’16:
Proceedings of the 33rd International Conference on Ma-
chine Learning.
Van Gael, J., and Zhu, X. 2007. Correlation clustering for
crosslingual link detection. In IJCAI ’07: Proceedings of the
20th International Joint Conference on Artiﬁcial Intelligence,
1744–1749.
Wakabayashi, Y. 1986. Aggregation of Binary Relations: Al-
gorithmic and Polyhedral Investigations. Ph.D. Dissertation,
Universit¨at Augsburg.
Xu, R., and Wunsch, D. 2005. Survey of clustering algo-
rithms. IEEE Transactions on Neural Networks 16(3):645–
678.

Acknowledgments

The authors would like to thank the anonymous reviewers for
their valuable suggestions and helpful comments. The ﬁrst
author is supported by a Grant-in-Aid for Research Activity
Start-up (No. 17H07357). This work was supported by JST
ERATO Grant Number JPMJER1201, Japan.

References

Agarwal, G., and Kempe, D. 2008. Modularity-maximizing
graph communities via mathematical programming. Euro-
pean Physical Journal B 66(3):409–418.
Aggarwal, C. C., and Reddy, C. K. 2013. Data Clustering:
Algorithms and Applications. CRC Press.
Ahn, K. J.; Cormode, G.; Guha, S.; McGregor, A.; and Wirth,
A. 2015. Correlation clustering in data streams. In ICML ’15:
Proceedings of the 32nd International Conference on Ma-
chine Learning, 2237–2246.
Altschul, S. F.; Gish, W.; Miller, W.; Myers, E. W.; and
Lipman, D. J. 1990. Basic local alignment search tool.
Journal of Molecular Biology 215(3):403–410.
Awasthi, P.; Balcan, M.-F.; and Voevodski, K. 2014. Local al-
gorithms for interactive clustering. In ICML ’14: Proceedings
of the 31st International Conference on Machine Learning,
550–558.
Bansal, N.; Blum, A.; and Chawla, S. 2004. Correlation
clustering. Machine Learning 56(1–3):89–113.
Barber, M. J. 2007. Modularity and community detection in
bipartite networks. Physical Review E 76:066102.
Berg, J., and J¨arvisalo, M. 2017. Cost-optimal constrained
correlation clustering via weighted partial maximum satisﬁa-
bility. Artiﬁcial Intelligence 244:110–142.
Bonchi, F.; Gionis, A.; and Ukkonen, A. 2013. Overlapping
correlation clustering. Knowledge and Information Systems
35(1):1–32.
Bruckner, S.; H¨uffner, F.; Komusiewicz, C.; and Niedermeier,
R. 2013. Evaluation of ILP-based approaches for partitioning
into colorful components. In SEA ’13: Proceedings of the
12th International Symposium on Experimental Algorithms,
176–187.
Chierichetti, F.; Dalvi, N.; and Kumar, R. 2014. Correlation
clustering in MapReduce. In KDD ’14: Proceedings of the
20th ACM SIGKDD International Conference on Knowledge
Discovery and Data Mining, 641–650.
Dinh, T. N., and Thai, M. T. 2015. Toward optimal com-
munity detection: From trees to general weighted networks.
Internet Mathematics 11(3):181–200.
Fortunato, S. 2010. Community detection in graphs. Physics
Reports 486(3):75–174.
Gonc¸alves, J. F., and Resende, M. G. C. 2004. An evolution-
ary algorithm for manufacturing cell formation. Computers
& Industrial Engineering 47(2–3):247–273.
Groover, M. P. 2007. Automation, Production Systems, and
Computer-Integrated Manufacturing. Prentice Hall Press.

1394

